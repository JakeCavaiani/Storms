#==================================================================================================
# Lab #4b: Data Visualization with ggplot
# Date: October 20, 2021
# Creator: Curry James Cunningham, College of Fisheries and Ocean Sciences, UAF
#
# Purpose: To explore the methods for data visualization in R using ggplot()
#
#
#==================================================================================================
#NOTES:

#==================================================================================================
# Please load the following packages:

library(datasets)
library(tidyverse)
library(ggplot2)
library(ggthemes)
library(gapminder)
library(ggmap)

# If you don't already have them installed use install.packages(" name of package here ")
#   NOTE: R will give you a warning message if you don't have a specific package:

# Loading required package: gapminder
# Warning message:
#   In library(package, lib.loc = lib.loc, character.only = TRUE, logical.return = TRUE,  :
#                there is no package called ‘gapminder’

# install.packages("datasets")
# install.packages("tidyverse")
# install.packages("ggplot2")
# install.packages("ggthemes")
# install.packages("gapminder")
# install.packages("ggmap")

# Exercise 1: ggplot - Aesthetics ====================================
# The ggplot() function offers a very efficient way to visualize data, allowing you to quickly:
#  1) Change the size or color of points based on other variables in a data frame (aesthetics)
#  2) Create multiple panels for different factor attributes of your data frame (faceting)
#  3) Explore different plot types

# There is a standard language to creating a ggplot, a so called "layered grammar of graphics".

# Every ggplot figure will include three important things:
#   1) A definition of the data, through the data= argument to the ggplot function.
#   2) The mapping of various figure aesthetic mappings, with the aes= argument
#   3) A geometric object definition with the addition of some geom_xxx() type.

?ggplot

# First we need data. We can work with the same mtcars dataset we saw in the last lab.
library(datasets)
data(mtcars)

str(mtcars)

# The creation of a ggplot figure will begin with a call to the ggplot() function

# In our ggplot call we specify the data as well as the aesthetic mapping.
#  The aesthetics aes(x=, y=) describe what we are plotting and how it is oriented.

ggplot(data=mtcars, mapping=aes(y=mpg, x=hp)) 

# What happened?

#   Well we have our coordinate system, our axes defined, our axis labels, and some background
#     grid lines. 

#   Next we need specify our geom (geometric object), which describes what we are going to plot
#    i.e. lines, points, ect.

# We layer this on with a "+" followed by the geometric object function: geom_xxx()

ggplot(data=mtcars, mapping=aes(y=mpg, x=hp)) +
  geom_point()

# Note that since the first and second arguments to the ggplot() function are the data and
#   the aesthetic mappings we can just drop the argument names:

ggplot(mtcars, aes(y=mpg, x=hp)) +
  geom_point()

# As we discussed in lecture, when we don't provide named arguments to our function
#   R will automatically assume the first argument (mtcars, i.e. the data)
#     is the data= argument, and the second argument provided is the mapping= argument

# We can easily switch this to a line plot by switching the geom_point() call
#   for a call to geom_line()

ggplot(data=mtcars, mapping=aes(y=mpg, x=hp)) +
  geom_line()

# THIS IS PROBABLY A LESS USEFUL WAY TO VISUALIZE THESE DATA !!!

# One important thing to note is that we can assign a ggplot as an object

g <- ggplot(mtcars, aes(y=mpg, x=hp)) +
        geom_point()

# Which happens to be a VERY COMPLEX list object
is.list(g)

str(g)

names(g)

# Challenge A

# This is a handy attribute of ggplots, and makes them portable and easy to
#   call or update later in your script.

# To plot my ggplot object I can either type the name of the object into my console
g

# Or call the plot() function on the ggplot object:

dev.off()

plot(g)


# Challenge A: Adjusting the ggplot list object ================================
# As we have just seen, we can save our ggplot as a very complex list object.
#   We can also see that this is a "named list" meaning the elements of the list
#     have names that we can use to access their contents with our old friend 
#       the $ symbol: g$
# 
# Using your knowledge of how to find and access list elements, please change the 
#   labels of the x and y axes, by changing elements of the "g" ggplot list object.
#     Change the y-axis label to "Miles per Gallon", and the x-axis label to
#       "Horsepower". Then call plot(g) to ensure your changes worked.
#   
#


# SOLUTION: ----------------------------------------
 













# --------------------------------------------------

# Changing other ggplot aesthetics =============================================

# The aesthetic mappings for our ggplot can extend to more dimensions of our data, 
#   beyond the x and y reference locations.

?aes

# We can represent other variables (columns) in our data frame associated with 
#   each observation (row) as different aesthetic elements.
# For example the color or size of our points.

# Perhaps we are interested in seeing if our fuel efficiency (mpg) and horsepower (hp)
#   relationship has any association with the number of cylinders. 

# We can EASILY color our points based on the number of cylinders for each car type
#   by changing the "col=" argument in the aes() 

g <- ggplot(mtcars, aes(y=mpg, x=hp, col=cyl)) +
  geom_point()
g


# Now we can easily see that high horsepower, low efficiency cars, tend to have more cylinders

# Now say we want to add another attribute, we could change the size of our 
#   points to show each car model's weight

# Again, just one more addition to the aesthetic definition is needed
# NOTE: We will use the natural log of weight to keep things simple.
g <- ggplot(mtcars, aes(y=mpg, x=hp, col=cyl, size=log(wt))) +
  geom_point()
g

# Now we can see that efficient, low horsepower cars tend to be lighter as well.

# Also, now we can easily see that the cars with intermediate horsepower with
#   EXTREMELY LOW fuel efficiency are some of the HEAVIEST VEHICLES.

# I wonder what those heavy land yachts are?

# Well we can re-order our data frame based on the weight of the cars
mtcars$wt  # Extracts and retuns the weight $wt column from our data frame

# REMEMBER: The returned object is a vector
is.vector(mtcars$wt)

# We can return the location references for the car weights in ascending order
#   with the order function. 
order(mtcars$wt) 

mtcars$wt[order(mtcars$wt)]

# While these are the location in the $wt vector, these are equivalently the
#   row references in the data frame :)

# But we want to list them from HIGHEST weight to LOWEST weight.

# We can use the rev() function to reverse the order
rev(order(mtcars$wt))

mtcars$wt[rev(order(mtcars$wt))]

# NOW WE CAN PUT IT ALL TOGETHER, AND USE THESE REFERENCES TO RE-ORDER THE ROWS
#   IN OUR DATA FRAME

mtcars[rev(order(mtcars$wt)),]

# From this example, we can see how ggplot() makes it easy to explore data
#  And plot multiple dimensions on one figure.

# The LINCOLN CONTINENTAL is the winner in 1974 greenhouse emitter category, but
#   I'm sure it drove like a dream. 

# OK, thank you for that diversion!

# Now, let's look at a couple alternative geoms.

# Perhaps we want to create boxplots comparing the fuel efficency across
#   categories represented by the number of cylinders.
# We can use geom_boxplot to do so, and adjust our x= and y= definitions in the
#   aesthetics definition aes().

# While $cyl is a continuous variable, we need to treat it as a factor or categorical
#   variable in this context to ensure or plot is properly created.

# We can use the factor() function to convert the numer of cylinders to a factor
#   with three levels

factor(mtcars$cyl)

g <- ggplot(mtcars, aes(x=factor(cyl), y=mpg)) +
       geom_boxplot()
g

# To make this a bit more visually appealing we can change the "fill" of our boxplots
#   by adjusting the fill= aesthetic, which is similar to col=, just for the interior
#     of specific geoms (kind of like bg=)
g <- ggplot(mtcars, aes(x=factor(cyl), y=mpg, fill=factor(cyl))) +
  geom_boxplot()
g


# Challenge B: Exporing Geoms ==================================================
# Now that we have explored the ggplot geom's for points, lines, and boxplots
#   please compare the fuel efficiency of automatic vs. manual transmissions
#     using violin plots.
# NOTE: You will need to identify which variable describes transmission type
#         by inspecting the data set documentation


# SOLUTION: ----------------------------------------












# --------------------------------------------------


# Exercise 2: Geom Smooth ======================================================

# We can also add general descriptions of the relationship we are plotting with
#  the geom_smooth() function

g <- ggplot(mtcars, aes(y=mpg, x=hp, col=cyl, size=log(wt))) +
  geom_point()
g

# Add geom_smooth() to the existing ggplot object
g + geom_smooth()

# This approximates the relationship with a loess smooth, or local polynomial
#   regression

# NOTE: We have not updated the original "g" object, just plotted it with the 
#   addition of the smooth above
g

# If we wanted to update the object we would need to assign it back to the original
#   "g" ggplot (named list) object

g <- g + geom_smooth()

g

# If we want to surpress the polygon describing the uncertainty in the geom_smooth
#   fit, we can set the se= argument to FALSE

g <- ggplot(mtcars, aes(y=mpg, x=hp, col=cyl, size=log(wt))) +
       geom_point() +
       geom_smooth(se=FALSE)
g

# Finally, we can change the method used for generating the line describing
#   the relationship.

?geom_smooth

# From the arguments to geom_smooth() we can see that method has several options:
# "lm", "glm", "gam", "loess"

g <- ggplot(mtcars, aes(y=mpg, x=hp, col=cyl, size=log(wt))) +
  geom_point() +
  geom_smooth(method="lm")
g


# Exercise 3: Faceting =========================================================

# Depending on how we want to visualize our data with ggplot, sometimes we may
#   want to create separate plotting panels for each level of a categorical (factor)
#   variable.

# This is somewhat equivalent to our use of par(mfrow=c(...)) or par(mfcol=c(...))
#   to create separate panels within a single plot.

# We will use the diamonds data set for this example.
library(datasets)
data(diamonds)

View(diamonds)

g <- ggplot(diamonds, aes(y=price, x=carat)) +
  geom_point()
g

# But perhaps we want to see how this varies as a function of cut, a factor
is.factor(diamonds$cut)

# We could color the points based on cut
g <- ggplot(diamonds, aes(y=price, x=carat, col=cut)) +
  geom_point(alpha=0.25) #Reducing the alpha to 0.25 makes the points more transparent, preventing overplotting
g

# Alternatively, we could "facet" by the cut, creating separate panels
g <- ggplot(diamonds, aes(y=price, x=carat, col=cut)) +
  geom_point(alpha=0.25) +
  facet_wrap(~cut)
g

# Again we could add a smooth to better show the relationship price~carat
g2 <- g + geom_smooth(col='black')
g2


# Lets do the same, but this time facet by clarity
g3 <- ggplot(diamonds, aes(y=price, x=carat, col=cut)) +
  geom_point(alpha=0.25) +
  facet_wrap(~clarity) +
  geom_smooth(col='black')
g3

# When we facet, the x and y axes are all specified as being the same, so the
#   individual panels are directly comparable. 
# However, sometimes having standardized axes is undesirable, so we can add
#   one of the following scale= arguments to the geom_smooth() call:
# scales="free"
# scales="free_y"
# scales="free_x"

ggplot(diamonds, aes(y=price, x=carat, col=cut)) +
  geom_point(alpha=0.25) +
  facet_wrap(~clarity)

# Free up the x-axis
ggplot(diamonds, aes(y=price, x=carat, col=cut)) +
  geom_point(alpha=0.25) +
  facet_wrap(~clarity, scales="free_x")

# Free up the y-axis 
# Doesn't make much difference in this case as most categories have equally
#   high price values

ggplot(diamonds, aes(y=price, x=carat, col=cut)) +
  geom_point(alpha=0.25) +
  facet_wrap(~clarity, scales="free_y")

# Free up both x and y
ggplot(diamonds, aes(y=price, x=carat, col=cut)) +
  geom_point(alpha=0.25) +
  facet_wrap(~clarity, scales="free")


# As we saw before, changing our geom_xxx will dictate what is plotted

# We can easily specify that we want to plot boxplots by changing to geom_boxplot()

ggplot(data=diamonds, 
       aes(y=price, x=clarity,fill=clarity)) +
       geom_boxplot()

# Or, perhaps we want to plot these data as density distributions
ggplot(data=diamonds, 
       aes(x=price, fill=clarity)) +
       geom_density(alpha=0.2)

# Again we can facet based on a factor variable to make our figure
#   more user friendly.

ggplot(data=diamonds, 
       aes(x=price, fill=clarity)) +
  geom_density(alpha=0.2) +
  facet_wrap(~clarity)

# As we saw above, under some circumstances we may want to allow our individual 
#   faceted panels to have different y-axis limits.
# This is a great example, we want to mre easily see the density distributions

ggplot(data=diamonds, 
       aes(x=price, fill=clarity)) +
  geom_density(alpha=0.2) +
  facet_wrap(~clarity, scales="free_y")

# Similar to face_wrap() is the facet_grid() function.
#   facet_grid() creates multiple panels as a function of two variables
#     where the first variable before the "~" defines the rows of panels
#       and the variable after the "~" 

# NOTE: We are required to share x and y axis limits when using facet_grid()

str(diamonds)

# Both cut and color are factor type variables, let's use those...

ggplot(data=diamonds, 
       aes(y=price, x=carat, col=clarity)) +
       geom_point(alpha=0.2) +
       facet_grid(cut~color)


# We can change which factor attributes define the rows and columns

ggplot(data=diamonds, 
       aes(y=price, x=carat, col=clarity)) +
       geom_point(alpha=0.2) +
       facet_grid(color~cut)



# Exercise 4: Scaling Colors and Fills =========================================

# We have a tremendous amount of freedom in how we define our ggplot
#   For example we can use the group of functions beginning with scale_ 
#   to adjust different attributes of our figure.
# For example scale_color_xxx() can be used to adjust the color scale used.

# Standard color scale
ggplot(data=diamonds, 
       aes(y=price, x=carat, col=price)) +
  geom_point(alpha=0.2) +
  facet_wrap(~cut)


# Define our own color scale for the price variable using the 
#   scale_color_gradient() function
ggplot(data=diamonds, 
       aes(y=price, x=carat, col=price)) +
  geom_point(alpha=0.2) +
  facet_wrap(~cut) +
  scale_color_gradient(low="red", high="green")

# We can explore other options
ggplot(data=diamonds, 
       aes(y=price, x=carat, col=price)) +
  geom_point(alpha=0.2) +
  facet_wrap(~cut) +
  scale_color_gradient2(low="blue", mid="purple", high="green")


# There are also built-in ggplot color palettes
ggplot(data=diamonds, 
       aes(y=price, x=carat, col=price)) +
  geom_point(alpha=0.2) +
  facet_wrap(~cut) +
  scale_color_viridis_c()


# Exercise 5: Axis Limits and Labels ===========================================

# It is important to understand how we change our axis limits and labels. 

# For the following examples we will use the gapminder data set:
?gapminder

# This rather expansive data set includes information on life expectancy (health) and 
#   gross domestic product (wealth) by country. Each row is a country.

str(gapminder)

# Lets plot the relationship between health and wealth
g <- ggplot(data = gapminder, mapping = aes(x=gdpPercap, y=lifeExp, color=continent)) +
  geom_point(alpha=0.25) +
  geom_smooth()

g

# Now to update the axis labels we can use the xlab() and ylab() functions
#   added on as additional layers with "+"

g <- g + xlab("Wealth (GDP in US $)")
g

# Now, the y-axis label

g <- g + ylab("Health (Life Expectancy in Years)")
g

# We can also add a title with ggtitle()

g <- g + ggtitle("Relationship Between Health and Wealth", 
                 subtitle="Gapminder Dataset")
g

# If we want to adjust our axis limits we can use the coord_cartesian() function
#   and the ylim= or xlim= argument.

g <- ggplot(data = gapminder, mapping = aes(x=gdpPercap, y=lifeExp, color=continent)) +
  geom_point(alpha=0.25) +
  geom_smooth() +
  coord_cartesian(ylim=c(50,100))

g

g <- ggplot(data = gapminder, mapping = aes(x=gdpPercap, y=lifeExp, color=continent)) +
  geom_point(alpha=0.25) +
  geom_smooth() +
  coord_cartesian(ylim=c(50,100), xlim=c(20000, 90000))

g

# Challenge C: Gapminder Data ==================================================
# Please plot the relationship between population size and life expectancy,
#   faceting by continent, and coloring points based on the Gross Domestic Product
#    per capita. Change the color scale for your points to something more exciting.


# SOLUTION: ----------------------------------------











# --------------------------------------------------

# Exercise 6: ggplot - Mapping Spatial Data ====================================
# The ggmap package allows easy creation of maps, and the ability to plot 
#   spatially-oriented data on these maps.

# The get_map() function


# install.packages("ggmap")
library(ggmap)

# Download data to create a map, subject to minimum/maximum longitude and latitude
map.dat <- get_map(location=c(-180, 45,
                              -130, 70),
                   maptype="toner-lite", source="stamen", crop=TRUE)
# Create the ggmap 
ggmap(map.dat) +
    ggtitle('Quick and Dirty Map')


# If we work with spatial data, we might want to plot these over the top of our map
#   we can do so with the same geom_xxx() arguments we would use for a standard ggplot.

map.dat <- get_map(location=c(-180, 45,
                              -130, 70),
                   maptype='toner-lite', source='stamen', crop=TRUE)
# Create the ggmap
ggmap(map.dat) +
  geom_point(aes(x=-145,y=50),  # Add points to the ggmap
                 col="red", size=2) +
  ggtitle('Quick and Dirty Map')


# Exercise 7: Saving ggplots ===================================================

# Saving your ggplot is extremely easy and uses the ggsave() function

g <- ggplot(data = gapminder, mapping = aes(x=gdpPercap, y=lifeExp, color=lifeExp)) +
  geom_point(alpha=0.25) +
  geom_smooth() +
  facet_wrap(~continent, scales="free") +
  xlab("Wealth (GDP in US $)") +
  ylab("Health (Life Expectancy in Years)") +
  scale_color_viridis_c()
  

g


ggsave(filename="Health-Wealth.pdf", plot=g, height=8, width=8, units="in")

